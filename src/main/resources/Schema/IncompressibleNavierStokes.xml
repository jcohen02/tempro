<?xml version="1.0" encoding="UTF-8"?>
<!-- Types available from the tempss schema: 
     positiveDouble, xs:double, xs:string, xs:positiveInteger, file -->
<IncompressibleNavierStokes xmlns="http://www.libhpc.imperial.ac.uk"
                            xmlns:libhpc="http://www.libhpc.imperial.ac.uk/SchemaAnnotation"
                            xmlns:tempss="http://www.libhpc.imperial.ac.uk/tempss/SchemaAnnotation">

  <libhpc:documentation>
    The Nektar++ finite element PDE solver for fluid flow using the 
    incompressible Navier-Stokes equation. Nektar++ user guide: 
    http://www.nektar.info/docs/manual/user-guide-4.0.0.pdf
  </libhpc:documentation>
  
  <ProblemSpecification>
    <libhpc:documentation>This section contains the parameters that define the 
      physics of the problem or, equivalently, the PDE coefficients. When 
      running a specific problem through the solver, the incompressible 
      Navier-Stokes equation should be re-scaled so that the only parameter 
      is the kinematic velocity. For this reason, units are not displayed, 
      since they depend onthere-scaling of the original problem.
    </libhpc:documentation>
    <Dimensions paramType="choice">
      <libhpc:documentation>Dimensions define the "real" mesh dimensions and not
        the augmentation with quasi-dimensions.
      </libhpc:documentation>
      <OneDimensional>
      </OneDimensional>
      <TwoDimensional>
        <QuasiDimensions optional="true">
          <HomModesY type="positiveDouble"/>
          <LY type="positiveDouble"/>
        </QuasiDimensions>
      </TwoDimensional>
      <ThreeDimensional>
        <QuasiDimensions optional="true" paramType="choice">
          <Single>
            <HomModesZ type="positiveDouble"/>
            <LZ type="positiveDouble"/>        
          </Single>
          <Double>
            <HomModesY type="positiveDouble"/>
            <LY type="positiveDouble"/>        
            <HomModesZ type="positiveDouble"/>
            <LZ type="positiveDouble"/>        
          </Double>
        </QuasiDimensions>
      </ThreeDimensional>
    </Dimensions>
    <ReynoldsNumber type="positiveDouble" optional="true" />
    <KinematicViscosity type="xs:string"/>
    <Geometry type="geometryFileName" inputType="file">
      <libhpc:documentation>
        The geometry on which the problem is being solved . Provide a Nektar 
        XML (with root NEKTAR element) containing a GEOMETRY element that will 
        be parsed to identify boundary regions.
      </libhpc:documentation>
    </Geometry>
    <BoundaryDetails type="BoundaryDetails">
      <libhpc:documentation>
        Here you can set up your boundary conditions and name them. When you 
        add a geometry file, this will be parsed to identify and build the 
        boundary regions which will appear here automatically. You can then 
        assign one of your boundary conditions to each region as required. 
      </libhpc:documentation>
    </BoundaryDetails>
    <InitialConditions optional="true">
      <libhpc:documentation>Value of the solution at time 0.</libhpc:documentation>
      <Variable repeatable="true">
        <VariableName type="xs:string"/>
        <Type paramType="choice">
          <Expression type="xs:string" />
          <File type="inputNameString" inputType="file">
          </File>
        </Type>
      </Variable>
    </InitialConditions>
  </ProblemSpecification>

  <NumericalSpecification>
    <libhpc:documentation>
      Specification of the particular problem to solve, including geometry, 
      initial conditions, boundary conditions, etc.
    </libhpc:documentation>
    <SolverType paramType="choice">
      <libhpc:documentation>See: http://www.nektar.info/wiki/3.3/UserGuide/Tutorial/IncNavierStokesSolver
        VelocityCorrectionScheme: see http://www.nektar.info/wiki/3.2/Tutorial/IncNavierStokesSolver/VCS
        DirectSolver: see http://www.nektar.info/wiki/3.2/Tutorial/IncNavierStokesSolver/DirectSolver
      </libhpc:documentation>
      <CoupledLinearNS>
      </CoupledLinearNS>
      <VelocityCorrectionScheme paramType="choice">
        <Standard></Standard>
        <WeakPressure></WeakPressure>
        <Mapping>
          <MappingType type="xs:string"/>
          <Expression type="xs:string"/>
        </Mapping>
      </VelocityCorrectionScheme>
    </SolverType>

    <Equation type="xs:string"  inputType="choice">
      <libhpc:documentation>
        SteadyStokes
        SteadyOseen
        UnsteadyStokes
        SteadyLinearisedNavierStokes
        UnsteadyLinearisedNavierStokes
        UnsteadyNavierStokes
      </libhpc:documentation>
      <tempss:item>SteadyStokes</tempss:item>
      <tempss:item>SteadyOseen</tempss:item>
      <tempss:item>UnsteadyStokes</tempss:item>
      <tempss:item>SteadyLinearisedNavierStokes</tempss:item>
      <tempss:item>UnsteadyLinearisedNavierStokes</tempss:item>
      <tempss:item>UnsteadyNavierStokes</tempss:item>
    </Equation>

    <TimeIntegration>
      <libhpc:documentation>Parameters setting the method for time integration.
      </libhpc:documentation>
      <Timing>
        <TimeStep type="xs:string" optional="true"/>
        <NumSteps type="xs:string" optional="true"/>
        <FinalTime type="xs:string" optional="true"/>
      </Timing>
      <TimeIntegrationMethod type="xs:string" inputType="choice">
        <tempss:item>NotProvided</tempss:item>
        <tempss:item>IMEXOrder1</tempss:item>
        <tempss:item>IMEXOrder2</tempss:item>
        <tempss:item>IMEXOrder3</tempss:item>
        <tempss:item>DIRKOrder1</tempss:item>
        <tempss:item>ForwardEuler</tempss:item>
        <tempss:item>BackwardEuler</tempss:item>
        <tempss:item>ClassicalRungeKutta4</tempss:item>
      </TimeIntegrationMethod>
    </TimeIntegration>    

    <Driver optional="true">
      <DriverType paramType="choice">        
        <Standard></Standard>
        <Adaptive></Adaptive>
        <ModifiedArnoldi></ModifiedArnoldi>
        <SteadyState></SteadyState>
        <Arpack>
          <ArpackProblemType type="xs:string"  inputType="choice">
            <tempss:item>LargestMag</tempss:item>
            <tempss:item>SmallestMag</tempss:item>
            <tempss:item>LargestReal</tempss:item>
            <tempss:item>SmallestReal</tempss:item>
            <tempss:item>LargestImag</tempss:item>
            <tempss:item>SmallestImag</tempss:item>
          </ArpackProblemType>        
        </Arpack>
      </DriverType>
    </Driver>

    <Projection type="xs:string"  inputType="choice">
      <libhpc:documentation>
        ContinuousGalerkin: enforces continuity of solution across element boundaries
        DiscontinuousGalerkin: doesn't enforce continuity, but better at 
                               capturing shocks in solution
      </libhpc:documentation>
      <tempss:item>ContinuousGalerkin</tempss:item>
      <tempss:item>DiscontinuousGalerkin</tempss:item>
      <tempss:item>MixedGalerkin</tempss:item>
    </Projection>
    
    <DiffusionAdvancement type="xs:string"  inputType="choice" optional="true">
      <libhpc:documentation>
        Specifies whether diffusion is handled implicitly or explicitly in 
        the time integration scheme. 
      </libhpc:documentation>
      <tempss:item>Implicit</tempss:item>
      <tempss:item>Explicit</tempss:item>
    </DiffusionAdvancement>

    <EvolutionOperator type="xs:string"  inputType="choice" optional="true">
      <tempss:item>Direct</tempss:item>
      <tempss:item>Adjoint</tempss:item>
      <tempss:item>NonLinear</tempss:item>
      <tempss:item>TransientGrowth</tempss:item>
      <tempss:item>SkewSymmetric</tempss:item>
      <tempss:item>AdaptiveSFD</tempss:item>
    </EvolutionOperator>

    <AdvectionForm type="xs:string" inputType="choice" optional="true">
      <libhpc:documentation>
        Sets the form in which the advection term is treated. See 
        http://www.nektar.info/wiki/3.4/UserGuide/Tutorial/IncNavierStokesSolver
      </libhpc:documentation>
      <tempss:item>Convective</tempss:item>
      <tempss:item>NonConservative</tempss:item>
      <tempss:item>Linearised</tempss:item>
      <tempss:item>Adjoint</tempss:item>
      <tempss:item>SkewSymmetric</tempss:item>
      <tempss:item>NoAdvection</tempss:item>
    </AdvectionForm>

    <Expansion>
      <libhpc:documentation>Specify details of how the solution function 
      will be approximated.</libhpc:documentation>
      <PolynomialOrder type="xs:positiveInteger">
        <libhpc:documentation>The order of polynomial expansion used on each 
          element. Higher order gives better approximation to the true solution. 
          The number of modes is equal to PolyNomialOrder + 1.</libhpc:documentation>
      </PolynomialOrder>
      <BasisType type="xs:string" inputType="choice">
        <libhpc:documentation>
          The type of polynomials used as a basis to expand the solution 
          function. There are two styles of basis polynomial: modal and nodal.
           
           Modal / hierarchical basis: don't need to redefine basis functions 
           when increase the order (but have to be modified to get zero at boundary).
           
           Nodal: have to be redefined when the polynomial order is increased, 
           but are naturally zero at the boundaries.
           
           Available choices:
             MODIFIED: Legendre polynomials (modal) that have been multiplied 
                       by two linear functions to make them zero at the boundaries.
             GAUSS_LAGRANGE: Lagrange polynomials (nodal)
             GLL_LAGRANGE: GLL is same as Gauss but with end points as well. 
                           Gauss-Lobatto-Legendre
             GLL_LAGRANGE_SMM: can only be used on  quadrilaterals and tetrehedrals
             CHEBYSHEV: another modal approach (similar to Fourier modes).
        </libhpc:documentation>
        <tempss:item>MODIFIED</tempss:item>
        <tempss:item>GAUSS_LAGRANGE</tempss:item>
        <tempss:item>GLL_LAGRANGE</tempss:item>
        <tempss:item>GLL_LAGRANGE_SEM</tempss:item>
        <tempss:item>CHEBYSHEV</tempss:item>
      </BasisType>
    </Expansion>
  </NumericalSpecification>

  <AdditionalParameters>
    <libhpc:documentation>
      This section contains all the parameters that specify the numerical 
      algorithm for solving the problem.
    </libhpc:documentation>
    
    <IOParams optional="true">
      <libhpc:documentation>
        This section contains parameters that specify administrative details.
      </libhpc:documentation>
      <IO_CFLSteps type="xs:string" optional="true"/>
      <IO_CheckSteps type="xs:string">
        <libhpc:documentation>
          The solution can be dumped out at regular intervals. This parameter 
          specifies the number of time steps for this interval.
        </libhpc:documentation>
      </IO_CheckSteps>
      <IO_InfoSteps type="xs:string">
        <libhpc:documentation>Specify the interval in time steps between each 
        print out of the current solution time.</libhpc:documentation>
      </IO_InfoSteps>
    </IOParams>

    <BaseFlow optional="true">
      <libhpc:documentation>Value of the solution at time 0.</libhpc:documentation>
      <Variable repeatable="true">
        <VariableName type="xs:string"/>
        <Type paramType="choice">
          <Expression type="xs:string" />
          <File type="baseNameString" inputType="file">
          </File>
        </Type>
      </Variable>
    </BaseFlow>

    <CustomInputs optional="true">
      <CustomExpression repeatable="true" optional="true">
        <Name type="xs:string"/>
        <Value type="xs:string"/>
      </CustomExpression>

      <CustomParameter repeatable="true" optional="true">
        <Name type="xs:string"/>
        <Value type="xs:string"/>
      </CustomParameter>
    </CustomInputs>

    <Filter repeatable="true" optional="true">
      <FilterType paramType="choice">
        <AeroForces>
          <OutputFile optional="true">
            <FileName type="xs:string"/>
            <Frequency type="xs:string"/>
          </OutputFile>
          <Boundary type="xs:string"/>        
        </AeroForces>
        <AverageFields>
          <OutputFile optional="true">
            <FileName type="xs:string"/>
            <Frequency type="xs:string"/>
          </OutputFile>          
          <SampleFile optional="true">
            <File type="fieldNameString" inputType="file">
            </File>
            <Frequency type="xs:string"/>
          </SampleFile>          
        </AverageFields>
        <Checkpoint>
          <OutputFile optional="true">
            <FileName type="xs:string"/>
            <Frequency type="xs:string"/>
          </OutputFile>
        </Checkpoint>
        <Energy>
          <OutputFile optional="true">
            <FileName type="xs:string"/>
            <Frequency type="xs:string"/>
          </OutputFile>
        </Energy>
        <HistoryPoints>
          <OutputFile optional="true">
            <FileName type="xs:string"/>
            <Frequency type="xs:string"/>
          </OutputFile>
          <Points repeatable="true">
            <X type="xs:string"/>
            <Y type="xs:string"/>
            <Z type="xs:string"/>
          </Points>          
        </HistoryPoints>
        <MovingAverage>
          <OutputFile optional="true">
            <FileName type="xs:string"/>
            <Frequency type="xs:string"/>
          </OutputFile>          
          <SampleFrequency type="xs:string"/>
          <Tau type="xs:string" optional="true"/>
        </MovingAverage>
        <ReynoldsStresses>
          <OutputFile optional="true">
            <FileName type="xs:string"/>
            <Frequency type="xs:string"/>
          </OutputFile>          
          <SampleFile optional="true">
            <File type="fieldNameString" inputType="file">
            </File>
            <Frequency type="xs:string"/>
          </SampleFile>     
          <Alpha type="xs:string" optional="true"/>
        </ReynoldsStresses>
        <Threshold optional="true">
          <Minimum optional="true">
            <OutputFile optional="true">
              <FileName type="xs:string"/>
            </OutputFile> 
            <ThresholdVar type="xs:string" optional="true"/>
            <ThresholdValue type="xs:string"/>
            <InitialValue type="xs:string"/>
            <StartTime type="xs:string" optional="true"/>
          </Minimum>
          <Maximum optional="true">
            <OutputFile optional="true">
              <FileName type="xs:string"/>
            </OutputFile> 
            <ThresholdVar type="xs:string" optional="true"/>
            <ThresholdValue type="xs:string"/>
            <InitialValue type="xs:string"/>
            <StartTime type="xs:string" optional="true"/>
          </Maximum>
        </Threshold>
      </FilterType>
    </Filter>

    <Force repeatable="true" paramType="choice" optional="true">
      <Absorption>
        <Coeff type="xs:string"/>
        <RefFlow type="xs:string"/>
        <RefFlowTime type="xs:string"/>
      </Absorption>
      <Body>
        <BodyForce type="xs:string"/>
      </Body>
      <Noise>
        <Whitenoise type="positiveDouble"/>
        <UpdateFreq type="positiveDouble" optional="true"/>
        <Nsteps type="positiveDouble" optional="true"/>
      </Noise>
    </Force>

    <Function repeatable="true" optional="true">
      <FunctionName type="xs:string"/>
        <Expression repeatable="true">
          <ExpressionVar type="xs:string" />
          <ExpressionName type="xs:string"/>
        </Expression>
    </Function>
  </AdditionalParameters>

  <AdvancedParameters>
    <CFL type="xs:string" optional="true"/>
    <GlobalSysSolution repeatable="true" optional="true">
      <MatrixInversion repeatable="true">
        <Field type="xs:string"/>
        <InversionType paramType="choice">
          <Direct>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
            </SubStructuring>
          </Direct>
          <Iterative>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
            </SubStructuring>
            <Preconditioner type="xs:string"  inputType="choice" optional="true">
              <tempss:item>Diagonal</tempss:item>
              <tempss:item>FullLinearSpace</tempss:item>
              <tempss:item>LowEnergyBlock</tempss:item>
              <tempss:item>Block</tempss:item>
              <tempss:item>FullLinearSpaceWithDiagonal</tempss:item>
              <tempss:item>FullLinearSpaceWithLowEnergyBlock</tempss:item>
              <tempss:item>FullLinearSpaceWithBlock</tempss:item>
            </Preconditioner>
            <SuccessiveRHS type="positiveIncDouble" optional="true">
            </SuccessiveRHS>
            <IterativeSolverTolerance type="positiveDouble">
            </IterativeSolverTolerance>
          </Iterative>
          <Xxt>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
              <tempss:item>MultiLevelStaticCondensation</tempss:item>
            </SubStructuring>
          </Xxt>
          <PETSc>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
              <tempss:item>MultiLevelStaticCondensation</tempss:item>
            </SubStructuring>
            <Preconditioner type="xs:string"  inputType="choice" optional="true">
              <tempss:item>Diagonal</tempss:item>
              <tempss:item>FullLinearSpace</tempss:item>
              <tempss:item>LowEnergyBlock</tempss:item>
              <tempss:item>Block</tempss:item>
              <tempss:item>FullLinearSpaceWithDiagonal</tempss:item>
              <tempss:item>FullLinearSpaceWithLowEnergyBlock</tempss:item>
              <tempss:item>FullLinearSpaceWithBlock</tempss:item>
            </Preconditioner>
            <IterativeSolverTolerance type="positiveDouble">
            </IterativeSolverTolerance>
          </PETSc>
        </InversionType>
      </MatrixInversion>
    </GlobalSysSolution>
    <SpectralhpDealiasing optional="true">
      <libhpc:documentation>Enables the use of spectral/hp dealiasing, which 
        can stablise certain simulations through the use of additional 
        integration of the nonlinear convective terms.
      </libhpc:documentation>
    </SpectralhpDealiasing>
    <SpectralVanishingViscosity optional="true">
      <libhpc:documentation>Adds additional damping for high-frequency modes 
        which may help in stabilising underresolved simulations.
      </libhpc:documentation>
      <SVVDiffCoeff type="positiveIncDouble">
        <libhpc:documentation>Adds additional damping for high-frequency modes 
          which may help in stabilising underresolved simulations.
        </libhpc:documentation>
      </SVVDiffCoeff>
      <SVVCutoffRatio type="positiveIncDouble01">
        <libhpc:documentation>Dictates the frequencies of the coefficients to 
          be damped. i.e. for polynomial order 7, a value of 0.75 means 
          damping is only applied to modes 6 and 7.
        </libhpc:documentation>
      </SVVCutoffRatio>
    </SpectralVanishingViscosity>
    <WeightPartitions type="xs:string" inputType="choice" optional="true">
      <libhpc:documentation>If using a hybrid mesh of more than one element type 
        , this should be set to NonUniform to give better parallel partitions.
      </libhpc:documentation>
      <tempss:item>Uniform</tempss:item>
      <tempss:item>NonUniform - DoF</tempss:item>
      <tempss:item>NonUniform - Boundary</tempss:item>
      <tempss:item>NonUniform - Both</tempss:item>
    </WeightPartitions>
  </AdvancedParameters>

</IncompressibleNavierStokes>
