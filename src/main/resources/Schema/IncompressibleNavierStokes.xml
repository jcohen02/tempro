<?xml version="1.0" encoding="UTF-8"?>
<!-- Types available from the tempss schema: 
     positiveDouble, xs:double, xs:string, xs:positiveInteger, file -->
<IncompressibleNavierStokes xmlns="http://www.libhpc.imperial.ac.uk"
                            xmlns:libhpc="http://www.libhpc.imperial.ac.uk/SchemaAnnotation"
                            xmlns:tempss="http://www.libhpc.imperial.ac.uk/tempss/SchemaAnnotation">

  <libhpc:documentation>
    The Nektar++ finite element PDE solver for fluid flow using the 
    incompressible Navier-Stokes equation. Nektar++ user guide: 
    http://www.nektar.info/docs/manual/user-guide-4.0.0.pdf
  </libhpc:documentation>
  
<!--   <DomainSpecification>
    <Dimensions type="xs:string" inputType="choice">
      <tempss:item>2D</tempss:item>
      <tempss:item>3D</tempss:item>
    </Dimensions>
    <libhpc:documentation>This section contains the parameters that define the 
      physics of the problem or, equivalently, the PDE coefficients. When 
      running a specific problem through the solver, the incompressible 
      Navier-Stokes equation should be re-scaled so that the only parameter 
      is the kinematic velocity. For this reason, units are not displayed, 
      since they depend onthere-scaling of the original problem.
    </libhpc:documentation>
    <ReynoldsNumber type="positiveDouble" optional="true" />
    <KinematicViscosity type="xs:string"/>
    <Geometry type="geometryFileName" inputType="file">
      <libhpc:documentation>
        The geometry on which the problem is being solved . Provide a Nektar 
        XML (with root NEKTAR element) containing a GEOMETRY element that will 
        be parsed to identify boundary regions.
      </libhpc:documentation>
    </Geometry>
    <BoundaryDetails type="BoundaryDetails">
      <libhpc:documentation>
        Here you can set up your boundary conditions and name them. When you 
        add a geometry file, this will be parsed to identify and build the 
        boundary regions which will appear here automatically. You can then 
        assign one of your boundary conditions to each region as required. 
      </libhpc:documentation>
    </BoundaryDetails>
    <InitialConditions optional="true">
      <libhpc:documentation>Value of the solution at time 0.</libhpc:documentation>
      <Variable repeatable="true">
        <VariableName type="xs:string"/>
        <Type paramType="choice">
          <Expression type="xs:string">
            <libhpc:documentation>
              Provide an expression describing the initial condition for this variable.
            </libhpc:documentation>
          </Expression>
          <File type="fileName" inputType="file">
            <libhpc:documentation>
              Provide a field file containing details of the initial condition for this variable.
            </libhpc:documentation>
          </File>
        </Type>
      </Variable>
    </InitialConditions>
  </DomainSpecification> -->

  <NumericalSpecification>
    <libhpc:documentation>
      Specification of the particular problem to solve, including geometry, 
      initial conditions, boundary conditions, etc.
    </libhpc:documentation>
    <SolverType type="xs:string" inputType="choice">
      <libhpc:documentation>See: http://www.nektar.info/wiki/3.3/UserGuide/Tutorial/IncNavierStokesSolver
        VelocityCorrectionScheme: see http://www.nektar.info/wiki/3.2/Tutorial/IncNavierStokesSolver/VCS
        DirectSolver: see http://www.nektar.info/wiki/3.2/Tutorial/IncNavierStokesSolver/DirectSolver
      </libhpc:documentation>
      <tempss:item>CoupledLinearNS</tempss:item>
      <tempss:item>VelocityCorrectionScheme</tempss:item>
      <tempss:item>VCSWeakPressure</tempss:item>
    </SolverType>
    <Equation type="xs:string"  inputType="choice">
      <libhpc:documentation>
        SteadyStokes
        SteadyOseen
        UnsteadyStokes
        SteadyLinearisedNavierStokes
        UnsteadyLinearisedNavierStokes
        UnsteadyNavierStokes
      </libhpc:documentation>
      <tempss:item>SteadyStokes</tempss:item>
      <tempss:item>SteadyOseen</tempss:item>
      <tempss:item>UnsteadyStokes</tempss:item>
      <tempss:item>SteadyLinearisedNavierStokes</tempss:item>
      <tempss:item>UnsteadyLinearisedNavierStokes</tempss:item>
      <tempss:item>UnsteadyNavierStokes</tempss:item>
    </Equation>

    <Driver type="xs:string"  inputType="choice" optional="true">
      <tempss:item>Standard</tempss:item>
      <tempss:item>Adaptive</tempss:item>
      <tempss:item>Arnoldi</tempss:item>
      <tempss:item>ModifiedArnoldi</tempss:item>
      <tempss:item>SteadyState</tempss:item>
    </Driver>

    <EvolutionOperator type="xs:string"  inputType="choice" optional="true">
      <tempss:item>Direct</tempss:item>
      <tempss:item>Adjoint</tempss:item>
      <tempss:item>NonLinear</tempss:item>
      <tempss:item>TransientGrowth</tempss:item>
      <tempss:item>SkewSymmetric</tempss:item>
      <tempss:item>AdaptiveSFD</tempss:item>
    </EvolutionOperator>

    <AdvectionForm type="xs:string" inputType="choice" optional="true">
      <libhpc:documentation>
        Sets the form in which the advection term is treated. See 
        http://www.nektar.info/wiki/3.4/UserGuide/Tutorial/IncNavierStokesSolver
      </libhpc:documentation>
      <tempss:item>Convective</tempss:item>
      <tempss:item>NonConservative</tempss:item>
      <tempss:item>Linearised</tempss:item>
      <tempss:item>Adjoint</tempss:item>
      <tempss:item>SkewSymmetric</tempss:item>
      <tempss:item>NoAdvection</tempss:item>
    </AdvectionForm>
    <CFL type="xs:string" optional="true"/>

    <Expansion>
      <libhpc:documentation>Specify details of how the solution function 
      will be approximated.</libhpc:documentation>
      <PolynomialOrder type="xs:positiveInteger">
        <libhpc:documentation>The order of polynomial expansion used on each 
          element. Higher order gives better approximation to the true solution. 
          The number of modes is equal to PolyNomialOrder + 1.</libhpc:documentation>
      </PolynomialOrder>
      <BasisType type="xs:string" inputType="choice">
        <libhpc:documentation>
          The type of polynomials used as a basis to expand the solution 
          function. There are two styles of basis polynomial: modal and nodal.
           
           Modal / hierarchical basis: don't need to redefine basis functions 
           when increase the order (but have to be modified to get zero at boundary).
           
           Nodal: have to be redefined when the polynomial order is increased, 
           but are naturally zero at the boundaries.
           
           Available choices:
             MODIFIED: Legendre polynomials (modal) that have been multiplied 
                       by two linear functions to make them zero at the boundaries.
             GAUSS_LAGRANGE: Lagrange polynomials (nodal)
             GLL_LAGRANGE: GLL is same as Gauss but with end points as well. 
                           Gauss-Lobatto-Legendre
             GLL_LAGRANGE_SMM: can only be used on  quadrilaterals and tetrehedrals
             CHEBYSHEV: another modal approach (similar to Fourier modes).
        </libhpc:documentation>
        <tempss:item>MODIFIED</tempss:item>
        <tempss:item>GAUSS_LAGRANGE</tempss:item>
        <tempss:item>GLL_LAGRANGE</tempss:item>
        <tempss:item>GLL_LAGRANGE_SEM</tempss:item>
        <tempss:item>CHEBYSHEV</tempss:item>
      </BasisType>
    </Expansion>
    <Projection type="xs:string"  inputType="choice">
      <libhpc:documentation>
        ContinuousGalerkin: enforces continuity of solution across element boundaries
        DiscontinuousGalerkin: doesn't enforce continuity, but better at 
                               capturing shocks in solution
      </libhpc:documentation>
      <tempss:item>ContinuousGalerkin</tempss:item>
      <tempss:item>DiscontinuousGalerkin</tempss:item>
    </Projection>
    <TimeIntegration>
      <libhpc:documentation>Parameters setting the method for time integration.
      </libhpc:documentation>
      <TimeIntegrationMethod type="xs:string" inputType="choice">
        <libhpc:documentation>
          Method of time stepping. See: http://www.nektar.info/wiki/3.2/Reference/TimeStepping
          
          - Formally Explicit Methods: These types of methods are considered 
            explicit from an ODE point of view. They are characterised by a 
            lower triangular coefficient matrix formula, i.e. formula for 
            formula. To avoid confusion, we make a further distinction:
          
            - direct explicit method: Only forward operators are required.
            - indirect explicit method: The inverse operator is required.
            - Diagonally Implicit Methods': Compared to explicit methods, 
              the coefficient matrix formula has now non-zero entries on the 
              diagonal. This means that each stage value depend on the stage 
              derivative at the same stage, requiring an implicit step. 
              However, the calculation of the different stage values is still 
              uncoupled. Best known are the DIRK schemes.
            - IMEX schemes: These schemes support the concept of being able to 
              split right hand forcing term into an explicit and implicit 
              component. This is useful in advection diffusion type problems 
              where the advection is handled explicity and the diffusion is 
              handled implicit.
              
          Choices supported by libhpc/nekkloud:
            "ForwardEuler"          Forward-Euler scheme
            "BackwardEuler"         Backward Euler scheme
            "IMEXOrder1"            IMEX 1st order scheme using Euler Backwards 
                                    Euler Forwards
            "IMEXOrder2"            IMEX 2nd order scheme using Backward 
                                    Different Formula and Extrapolation
            "IMEXOrder3"            IMEX 3rd order scheme using Backward 
                                    Different Formula and Extrapolation
            "DIRKOrder1"            Diagonally Implicit Runge-Kutta scheme of order 1
            "ClassicalRungeKutta4"  4th order Runge Kutta scheme
        </libhpc:documentation>
        <tempss:item>NotProvided</tempss:item>
        <tempss:item>IMEXOrder1</tempss:item>
        <tempss:item>IMEXOrder2</tempss:item>
        <tempss:item>IMEXOrder3</tempss:item>
        <tempss:item>DIRKOrder1</tempss:item>
        <tempss:item>ForwardEuler</tempss:item>
        <tempss:item>BackwardEuler</tempss:item>
        <tempss:item>ClassicalRungeKutta4</tempss:item>
      </TimeIntegrationMethod>
      <DiffusionAdvancement type="xs:string"  inputType="choice" optional="true">
        <libhpc:documentation>
          Specifies whether diffusion is handled implicitly or explicitly in 
          the time integration scheme. 
        </libhpc:documentation>
        <tempss:item>Implicit</tempss:item>
        <tempss:item>Explicit</tempss:item>
      </DiffusionAdvancement>
    </TimeIntegration>    
  </NumericalSpecification>

<!--   <AdditionalParameters>
    <libhpc:documentation>
      This section contains all the parameters that specify the numerical 
      algorithm for solving the problem.
    </libhpc:documentation>

    <CustomExpression repeatable="true" optional="true">
      <Name type="xs:string"/>
      <Value type="xs:string"/>
    </CustomExpression>

    <CustomParameter repeatable="true" optional="true">
      <Name type="xs:string"/>
      <Value type="xs:string"/>
    </CustomParameter>

   <SpectralhpDealiasing optional="true">
      <libhpc:documentation>Enables the use of spectral/hp dealiasing, which 
        can stablise certain simulations through the use of additional 
        integration of the nonlinear convective terms.
      </libhpc:documentation>
    </SpectralhpDealiasing>
    <SpectralVanishingViscosity optional="true">
      <libhpc:documentation>Adds additional damping for high-frequency modes 
        which may help in stabilising underresolved simulations.
      </libhpc:documentation>
      <SVVDiffCoeff type="positiveIncDouble">
        <libhpc:documentation>Adds additional damping for high-frequency modes 
          which may help in stabilising underresolved simulations.
        </libhpc:documentation>
      </SVVDiffCoeff>
      <SVVCutoffRatio type="positiveIncDouble01">
        <libhpc:documentation>Dictates the frequencies of the coefficients to 
          be damped. i.e. for polynomial order 7, a value of 0.75 means 
          damping is only applied to modes 6 and 7.
        </libhpc:documentation>
      </SVVCutoffRatio>
    </SpectralVanishingViscosity>
    <WeightPartitions type="xs:string" inputType="choice" optional="true">
      <libhpc:documentation>If using a hybrid mesh of more than one element type 
        , this should be set to NonUniform to give better parallel partitions.
      </libhpc:documentation>
      <tempss:item>Uniform</tempss:item>
      <tempss:item>NonUniform - DoF</tempss:item>
      <tempss:item>NonUniform - Boundary</tempss:item>
      <tempss:item>NonUniform - Both</tempss:item>
    </WeightPartitions>

    <GlobalSysSolution repeatable="true" optional="true">
      <MatrixInversion repeatable="true">
        <Field type="xs:string"/>
        <InversionType paramType="choice">
          <Direct>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
            </SubStructuring>
          </Direct>
          <Iterative>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
            </SubStructuring>
            <Preconditioner type="xs:string"  inputType="choice" optional="true">
              <tempss:item>Diagonal</tempss:item>
              <tempss:item>FullLinearSpace</tempss:item>
              <tempss:item>LowEnergyBlock</tempss:item>
              <tempss:item>Block</tempss:item>
              <tempss:item>FullLinearSpaceWithDiagonal</tempss:item>
              <tempss:item>FullLinearSpaceWithLowEnergyBlock</tempss:item>
              <tempss:item>FullLinearSpaceWithBlock</tempss:item>
            </Preconditioner>
            <SuccessiveRHS type="positiveIncDouble" optional="true">
            </SuccessiveRHS>
            <IterativeSolverTolerance type="positiveDouble">
            </IterativeSolverTolerance>
          </Iterative>
          <Xxt>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
              <tempss:item>MultiLevelStaticCondensation</tempss:item>
            </SubStructuring>
          </Xxt>
          <PETSc>
            <SubStructuring type="xs:string"  inputType="choice">
              <tempss:item>Full</tempss:item>
              <tempss:item>StaticCondensation</tempss:item>
              <tempss:item>MultiLevelStaticCondensation</tempss:item>
            </SubStructuring>
            <Preconditioner type="xs:string"  inputType="choice" optional="true">
              <tempss:item>Diagonal</tempss:item>
              <tempss:item>FullLinearSpace</tempss:item>
              <tempss:item>LowEnergyBlock</tempss:item>
              <tempss:item>Block</tempss:item>
              <tempss:item>FullLinearSpaceWithDiagonal</tempss:item>
              <tempss:item>FullLinearSpaceWithLowEnergyBlock</tempss:item>
              <tempss:item>FullLinearSpaceWithBlock</tempss:item>
            </Preconditioner>
            <IterativeSolverTolerance type="positiveDouble">
            </IterativeSolverTolerance>
          </PETSc>
        </InversionType>
      </MatrixInversion>
    </GlobalSysSolution>

    <Function repeatable="true" optional="true">
      <Name type="xs:string"/>
      <Variable repeatable="true">
        <Name type="xs:string"/>
        <Expression repeatable="true">
          <ExpressionVar type="xs:string" />
          <ExpressionName type="xs:string"/>
        </Expression>
      </Variable>
    </Function>

    <Filter repeatable="true" optional="true">
      <Type type="xs:string"/>
      <Variable repeatable="true">
        <Param repeatable="true">
          <ParamName type="xs:string" />
          <ParamValue type="xs:string"/>
        </Param>
      </Variable>
    </Filter>
  </AdditionalParameters> -->

<!--   <DurationIO>
    <libhpc:documentation>
      This section contains parameters that specify administrative details.
    </libhpc:documentation>
      <FinalTime type="xs:string" optional="true"/>
      <TimeStep type="xs:string" optional="true"/>
      <NumSteps type="xs:string" optional="true"/>
    <IO_CheckSteps type="xs:string">
      <libhpc:documentation>
        The solution can be dumped out at regular intervals. This parameter 
        specifies the number of time steps for this interval.
      </libhpc:documentation>
    </IO_CheckSteps>
    <IO_InfoSteps type="xs:string">
      <libhpc:documentation>Specify the interval in time steps between each 
      print out of the current solution time.</libhpc:documentation>
    </IO_InfoSteps>
  </DurationIO> -->

</IncompressibleNavierStokes>